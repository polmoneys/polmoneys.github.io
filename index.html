<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,400,700" rel="stylesheet">
  <link href="./x.css" rel="stylesheet">
  <title> pol moneys 2017 </title>
</head>

<body>
  <img src="./logo.png" class="logo"/>
<p><span class="txt-alert">'The first requirement of The Economist is that it should be readily understandable. Clarity of writing usually follows clarity of thought.'</span> - The Economist style Guide.</p>
<p>What a time to be alive, this text is a work in progress.</p>
<p>I'm all in with <a href="http://styled-components.com">styled-components</a> and couldn't be happier, it just makes the developer experience much better.</p>


<p>We've done fine with preprocessors and a bunch of utility CSS files, imagine divs with flexbox classes as <span class="txt-bold">'col-center justify-content-center align-items-center'</span>, and react-media to render chunks of markup at diferent breakpoints.  </p>
<p>It was the first step towards minimizing CSS and the hassle of naming classes (at work we are trilingual).</p>

<code><pre class="c">
import React, { Component, PropTypes } from "react";
<strong class="c--">import Media from 'react-media';</strong>
import Footer from './widgets/footer';
import FooterMobile from './widgets/footer-mobile';

class App extends Component {
  render() {
    return (
      &lt;Media query="(min-width: 992px)"&gt;
        {matches =>
          matches
            ? &lt;div&gt;
            <strong class="c--"> &lt;Footer /&gt;</strong>
              &lt;/div&gt;
            : &lt;div&gt;
            <strong class="c--"> &lt;FooterMobile /&gt;</strong>
              &lt;/div&gt;
          }
      &lt;/Media&gt;
    )
  }
}    
</pre>
</code>

<p>The trend was there, try to make self contained widgets with inmutable CSS classes and one Javascript object with styles to avoid polluting a CSS file with one-use <span class="txt-bold">#id or .class</span>.</p>
<code><pre><strong class="c">
export const Bold = ({ children }) => {</strong>
  <strong class="c--">
  const styles = {
      fontWeight: 700
    };</strong>  
<strong class="c">
    return (
        &lt;span style={styles}&gt;
        {children}
        &lt;/span&gt;
    );
  };</strong>
</pre>
</code>
<p>And use it:</p>
<code><pre class="c">
import { Bold } from "../widgets/txt";

export default () => (
  &lt;div&gt;
  &lt;p&gt;Hello, &lt;Bold&gt;bold&lt;/Bold&gt;&lt;/p&gt;
  &lt;/div&gt;
)</pre>
</code>

<p>We had a txt.js file under  <span class="txt-bold">/widgets</span> with some of these:</p>

<code><pre class="c">
export const Touchable = ({ children }) => {
  const styles = {
    cursor: "pointer"
  };
  return (
     &lt;span style={styles}&gt;
      {children}
     &lt;/span&gt;
  );
};

export const FontMegrim = ({ children, uppercase, typeScale }) => {
  const styles = {
    fontFamily: "Megrim, cursive",
    textTransform: uppercase ? "uppercase" : "none"
  };
  return (
    &lt;span style={styles} className={typeScale}&gt;
      {children}
    &lt;/span&gt;
  );
};</pre>
</code>

<p>No need to reference a .class on a immutable/utilities CSS file, the goal always was self containtment and minimizing the amount of files in big projects.</p>
<p>Thing is, we can do better and have it all right here right now.</p>

<code><pre class="c">
import styled, { css,keyframes } from 'styled-components';

export default () => (
  &lt;div&gt;
  
    &lt;Paragraph <strong class="c---">tint="red" uppercase</strong>&gt;
      Hello World
    &lt;/Paragraph&gt;

    &lt;Paragraph&gt;
    &lt;Word tint="#999"&gt; Hello &lt;/Word&gt; &lt;Bold&gt;World&lt;/Bold&gt;
    &lt;/Paragraph&gt;

  &lt;/div&gt;
)</pre>
<pre class="c-">
<strong class="c---">const Paragraph = styled.p`
  color: ${props => props.tint ? tint : '#444'};
  text-transform: ${props => props.uppercase ? 'uppercase' : 'none'};
`;</strong>
const Bold = styled.span`
  font-weight:bold;
`;
const Uppercase = styled.span`
  text-transform:uppercase;
`;
const Word = styled.span`
  color: ${props => props.tint ? tint : '#444'};
`;</pre>
</code>

<p>Moar Lo-Fi styled components you can use: </p>

<code><pre class="c-">
const TextEllipsis = styled.p`
  max-width: 100%;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  word-wrap: normal !important;
`;

const VerticalText = styled.p`
  writing-mode: vertical-lr;
`;</pre>
</code>

<p>Color variations on buttons and force links to appear like buttons is one of the oldest fights. Now we can win it swiftly.</p>
<p>Styled-components' <span class="txt-bold">withComponent</span> and  <span class="txt-bold">extend</span> methods are all you'll ever need to make contextual changes without adding specificity by creating #id > descendant relationships on a CSS file ever again.</p>

<code><pre>
<strong class="c-">
const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

const Touchable = styled.button`
  animation: 1s ${fadeIn} ease-out;
  cursor:pointer;
  touch-action: manipulation;
  -webkit-appearance: button;
  
  & > * {
    pointer-events: none;
  }
`;

const TouchableBranded = Touchable.extend`
  color:#fff;
  background: pink;

  &:hover {
    opacity:.8;
  }
`;</strong>
<strong class="c---">
const Link = Touchable.withComponent('a')

const LinkUnderline = Link.extend`
  text-decoration:underline;
`;</strong>
</pre>
</code>
<p>And use it:</p>
<code><pre class="c">
  export default () => (
    &lt;div&gt;
    
      &lt;Touchable 
      onClick={e => console.log(e)}&gt; 
        Normal Touchable 
      &lt;/Touchable&gt;
  
      &lt;TouchableBranded 
      onClick={e => console.log(e)}&gt; 
        Branded Touchable 
      &lt;/TouchableBranded&gt;
  
      &lt;Link href="/"&gt;
        Normal Link 
      &lt;/Link&gt;
  
      &lt;LinkUnderline href="/"&gt;
        Link with Underline 
      &lt;/LinkUnderline&gt;
    
    &lt;/div&gt;
  )</pre>
</code>

<p>We could style the Touchables above with props but to make things a bit more easy to come back to it unless they are obvious I don't mind writing a bit more. I was one of those who could never tell if a color was 'secondary' or 'calm'...</p>
<p>As you contemplate the Way let's consider a classic piece of UI and marvel ourselves on how close to real CSS styled-components feels right now. Most of it works, no need to ditch fav old tricks like <span class="txt-bold">:not(:last-of-type)</span>.</p>

<code><pre>
<strong class="c">
export default () => (
  &lt;div&gt;
    
    &lt;PopUp&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt; 
      &lt;/div&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt;
      &lt;/div&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt; 
      &lt;/div&gt;
    &lt;/PopUp&gt;
  
  &lt;/div&gt;
)</strong>
<strong class="c--">const foo = '.4rem'; </strong>
<strong class="c---">
const PopUp = styled.div`
  border-radius:${foo};
  background: ${props => props.dark ? '#444' : '#f9f9f9'};
  color: ${props => props.dark ? '#f9f9f9' : '#444'};</strong>
<strong class="c--">
  @media (min-aspect-ratio: 16/9) {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
  }

  > div:not(:last-of-type) {
    margin-bottom:1rem;
  }

  #crash & {
    display: none;
  }</strong>
<strong class="c---">
  ${props =>
    props.disabled &&
    css`
      background-color: #777;
    `};
`;</strong></pre>
</code>
<p>All the powers right here right now. Nice. </p>
<p>One last Real World Example, it's a complex component/piece of UI but it reads like a poem and does not need any 'external' CSS to shine. </p>
<p>At work we've build our own feedback 'tool', when a client fills a bug we ask for a few things, one of them is on which device the err ocurred (think breakpoint, OS/Software has it's own picker). </p>

<img class="screenshot" src="./devices.png" />

<p>We had little time so we hack the devices with CSS (I now know better than to lose myself browsing The Noun Project).</p>

<code><pre>
  <strong class="c">
class CreateBug extends Component {
  state = {
    device: "phone",
  };      

  renderDeviceSelector() {
    if (!this.state.device) return;

    return (
      &lt;Devices&gt;    
      &lt;Iphone
      pressed={this.state.device == "phone"}
      onClick={() => this.setState({ device: "phone" })}
    /&gt;
      &lt;Tablet
      pressed={this.state.device == "tablet"}
      onClick={() => this.setState({ device: "tablet" })}
    /&gt;
      &lt;Tablet
      pressed={this.state.device == "tablet-landscape"}
      onClick={() => this.setState({ device: "tablet-landscape" })}
      landscape
    /&gt;
      &lt;Desktop
      pressed={this.state.device == "desktop"}
      onClick={() => this.setState({ device: "desktop" })}
    /&gt;
  &lt;/Devices&gt;
      )
  
  }

  render() {

    return (
      &lt;Editor&gt;
       {this.renderDeviceSelector()}
      &lt;/Editor&gt;
    )
  }
}   
</strong>
 <strong class="c-">
const Devices = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
`;

const Mobile = styled.span`
  &:before,
  &:after {
    content: "";
    position: absolute;
  }

  &:before {
    width: 15px;
    height: 3px;
    left: 50%;
    top: 4px;
    transform: translateX(-50%);
    border-radius: 15px;
    background: #222;
    background-clip: padding-box;
  }

  &:after {
    width: 6px;
    height: 6px;
    left: 50%;
    bottom: 4px;
    transform: translateX(-50%);
    border-radius: 50%;
    background: #222;
    background-clip: padding-box;
  }
`;</strong>
<strong class="c--">
const Iphone = Mobile.extend`
  position: relative;
  width: 32px;
  height: 50px;
  border: 3px solid #222;
  border-radius: 3px;
  background-color: #fff;
  background-clip: padding-box;</strong>
  <strong class="c---">
  ${props => props.pressed && css`background-color: red;`};
  `;</strong>
<strong class="c--">
const Tablet = Mobile.extend`
  position: relative;
  width: 50px;
  height: 60px;
  border: 3px solid #222;
  border-radius: 3px;
  background-color: #fff;
  background-clip: padding-box;</strong>
<strong class="c---">
  ${props => props.pressed && css`background-color: red;`};
  ${props => props.landscape && css`transform: rotate(90deg);`}
  `;</strong>
<strong class="c--">
const Desktop = styled.span`
  position: relative;
  width: 120px;
  height: 75px;
  border: 3px solid #222;
  border-radius: 3px;
  background-color: #fff;
  background-clip: padding-box;

  &:before,
  &:after {
    content: "";
    position: absolute;
  }

  &:before {
    width: 15px;
    height: 3px;
    left: 50%;
    top: 4px;
    transform: translateX(-50%);
    border-radius: 15px;
    background: #222;
    background-clip: padding-box;
  }

  &:after {
    display: none;
  }</strong>
  <strong class="c---">
  ${props => props.pressed && css`background-color: red;`};
  `;</strong></pre>
</code>

<p>You could atomize things more and make renderDeviceSelector a component with it's own file, do what you feel is best, find your balance. In my experience, the bigger the project, the more I hate naming files, importing them, switching folders...mental debt for the future self.</p>
<p class="txt-bold">With Styled-components I can write better 'files', easier on the eyes of my teammates and future self. </p>
<p>(What I'm trying to say is find your way and don't settle with your current flow just yet)</p>

</body>

</html>