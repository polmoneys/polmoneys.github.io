<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,400,700" rel="stylesheet">
  <link href="./x.css" rel="stylesheet">
  <title> pol moneys 2017 </title>
</head>

<body>
<p class="txt-bold">THIS IS A WORK IN PROGRESS. NOT READY FOR PUBLIC EXPOSURE.</p>
<p>What a time to be alive.</p>
<p>I'm all in with <a href="http://styled-components.com">styled components</a> and couldn't be happier. This is my current flow, thought I'd share it with you.</p>

<!-- <p>TLDR;</p>
<p>* The 'it works on a t-shirt' test is my go-to test.</p>
<p>* Components and styles in the same file but don't atomize too much.</p>
<p>* Writing, be it new or maintainance, need to be joyful.  </p> -->


<p class="txt-bold"> How we got here</p>

<p>Until now the approach was a combination of utility css files (imagine divs with flexbox classes as 'col-center justify-content-center align-items-center') and react media to render chunks of markup at diferent breakpoints.  </p>
<p>It was the first step towards minimizing lenght of CSS and the hassle of naming classes (at work we are trilingual).</p>

<code>
<pre class="c">
import React, { Component, PropTypes } from "react";
<strong class="c--">import Media from 'react-media';</strong>
import Footer from './widgets/footer';
import FooterMobile from './widgets/footer-mobile';

class App extends Component {
  render() {
    return (
      &lt;Media query="(min-width: 992px)"&gt;
        {matches =>
          matches
            ? &lt;div&gt;
            <strong class="c--"> &lt;Footer /&gt;</strong>
              &lt;/div&gt;
            : &lt;div&gt;
            <strong class="c--"> &lt;FooterMobile /&gt;</strong>
              &lt;/div&gt;
          }
      &lt;/Media&gt;
    )
  }
}    
</pre>
</code>

<p>The trend was there, try to make self contained widgets with inmutable CSS classes and one Javascript object with styles to avoid polluting a CSS file with one-use clutter (be it #id or .class).</p>
<p>We had a txt.js file under widgets folder with some of these:</p>

<code>
  <pre class="c">


export const Bold = ({ children }) => {
  const styles = {
    fontWeight: 700
  };
  return (
     &lt;span style={styles}&gt;
      {children}
     &lt;/span&gt;
  );
};

export const Touchable = ({ children }) => {
  const styles = {
    cursor: "pointer"
  };
  return (
     &lt;span style={styles}&gt;
      {children}
     &lt;/span&gt;
  );
};

export const FontMegrim = ({ children, uppercase, typeScale }) => {
  const styles = {
    fontFamily: "Megrim, cursive",
    textTransform: uppercase ? "uppercase" : "none"
  };
  return (
    &lt;span style={styles} className={typeScale}&gt;
      {children}
    &lt;/span&gt;
  );
};

// use anywhere
// import { FontMegrim, Bold,Touchable } from "../widgets/txt";
// &lt;p&gt; &lt;FontMegrim uppercase&gt;Hello, &lt;Bold&gt;bold&lt;/Bold&gt;&lt;/p&gt; &lt;/FontMegrim&gt;
</pre>
</code>

<p>Notice how most don't reference a .txt-bold class on a immutable/utilities CSS file, the goal was self containtment when possible. </p>
<p>The above line is a lie if you look at FontMegrim and how it requires a classname that assigns font-size.The idea is to set the default font-family and font-size on the global CSS file and use this component on titles/headers.</p>
<p>Thing is, we can do better and have it all right here right now.</p>

<code>
<pre class="c">
import styled, { css,keyframes } from 'styled-components';

export default () => (
  &lt;div&gt;
  
    &lt;Paragraph <strong class="c---">tint="red" uppercase</strong>&gt;
      Hello World
    &lt;/Paragraph&gt;

    &lt;Paragraph&gt;
    &lt;Word tint="#999"&gt; Hello &lt;/Word&gt; &lt;Bold&gt;World&lt;/Bold&gt;
    &lt;/Paragraph&gt;

  &lt;/div&gt;
)
</pre>

  <pre class="c-">
<strong class="c---">const Paragraph = styled.p`
 color: ${props => props.tint ? tint : '#444'};
text-transform: ${props => props.uppercase ? 'uppercase' : 'none'};
`;</strong>
const Bold = styled.span`
  font-weight:bold;
`;
const Uppercase = styled.span`
text-transform:uppercase;
`;
const Word = styled.span`
color: ${props => props.tint ? tint : '#444'};
`;

</pre>
</code>

<p>Moar Lo-Fi styled components I may have used in the past: </p>

<code>
  <pre class="c-">
const TextEllipsis = styled.p`
  max-width: 100%;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  word-wrap: normal !important;
`;

const VerticalText = styled.p`
  writing-mode: vertical-lr;
`;
  </pre>
</code>

<p>If we transition to a more ambitious endeavour athe nd accept the fact that backbone of any website are links and buttons, we can go for another small effort big #win.</p>
<p>Color variations on buttons and force links to appear like buttons is one of the oldest fights. Now we can win it swiftly.</p>

<code>
  <pre class="c">
export default () => (
  &lt;div&gt;
  
    &lt;Touchable 
    onClick={e => console.log(e)}&gt; 
      Normal Touchable 
    &lt;/Touchable&gt;

    &lt;TouchableBranded 
    onClick={e => console.log(e)}&gt; 
      Branded Touchable 
    &lt;/TouchableBranded&gt;

    &lt;Link href="/"&gt;
      Normal Link 
    &lt;/Link&gt;

    &lt;LinkUnderline href="/"&gt;
      Link with Underline 
    &lt;/LinkUnderline&gt;
  
  &lt;/div&gt;
)
</pre>
</code>


<code>
  <pre class="c-">
const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

const Touchable = styled.button`
  animation: 1s ${fadeIn} ease-out;
  cursor:pointer;
  touch-action: manipulation;
  -webkit-appearance: button;
  
  & > * {
    pointer-events: none;
  }
`;

const TouchableBranded = Touchable.extend`
  background: pink;
  color:#fff;

  &:hover {
    opacity:.8;
  }
`;
</pre>
<pre class="c---">
const Link = Touchable.withComponent('a')

const LinkUnderline = Link.extend`
  text-decoration:underline;
`;
</pre>
</code>
<p>You could have styled the Touchables above with props but to make things a bit more clear for my teammates unless they are obvious ('uppercase') I don't mind writing a bit more. I was one of those who could never tell if a color was 'primary' or 'danger'...</p>
<p>As you contemplate the Way let's consider a classic piece of UI and marvel ourselves with all the Css we can use in JS. Most of it works, no need to ditch your fav old tricks.</p>

<code>
  <pre class="c">
export default () => (
  &lt;div&gt;
    
    &lt;PopUp&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt; 
      &lt;/div&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt;
      &lt;/div&gt;
      &lt;div&gt; 
        &lt;Placeholder/&gt; 
      &lt;/div&gt;
    &lt;/PopUp&gt;
  
  &lt;/div&gt;
)  
</pre>

  <pre class="c--">
const foo = '.4rem';
</pre>
<pre class="c---">
const PopUp = styled.div`
  border-radius:${foo};
  background: ${props => props.dark ? '#444' : '#f9f9f9'};
  color: ${props => props.dark ? '#f9f9f9' : '#444'};
</pre>
<pre class="c--">
  @media (min-aspect-ratio: 16/9) {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
  }

  > div:not(:last-of-type) {
    margin-bottom:1rem;
  }

  #crash & {
    display: none;
  }
</pre>
<pre class="c---">
  ${props =>
    props.notification &&
    css`
      background-color: #777;
    `};
`;
</pre>
</code>
<p>All the powers right here right now. Nice. </p>
<p>Those final lines are a real powerful combo paired with React and State mgmt. </p>



<p> Real World Example </p>
<p>We've built at work our own feedback tool, when a client fills a bug we ask for a few things, one of them is on which device the err ocurred (think breakpoint, OS/Software has it's own picker) </p>

<img class="screenshot" src="./devices.png" />

<p>Let's make the devices with CSS because we had little time and didn't want to lose myself browsing thenounproject.com:</p>

<code>
  <pre class="c">
class CreateBug extends Component {
  state = {
    device: "phone",
  };      

  renderDeviceSelector() {
    if (!this.state.device) return;

    return (
      &lt;Devices&gt;    
      &lt;Iphone
      pressed={this.state.device == "phone"}
      onClick={() => this.setState({ device: "phone" })}
    /&gt;
      &lt;Tablet
      pressed={this.state.device == "tablet"}
      onClick={() => this.setState({ device: "tablet" })}
    /&gt;
      &lt;Tablet
      pressed={this.state.device == "tablet-landscape"}
      onClick={() => this.setState({ device: "tablet-landscape" })}
      landscape
    /&gt;
      &lt;Desktop
      pressed={this.state.device == "desktop"}
      onClick={() => this.setState({ device: "desktop" })}
    /&gt;
  &lt;/Devices&gt;
      )
  
  }

  render() {

    return (
      &lt;Editor&gt;
       {this.renderDeviceSelector()}
      &lt;/Editor&gt;
    )
  }
}   
</pre>
 <pre class="c-">
const Devices = styled.div`
  padding: 1rem;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
`;

const Mobile = styled.span`
  &:before,
  &:after {
    position: absolute;
    content: "";
  }

  &:before {
    top: 4px;
    width: 15px;
    height: 3px;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    border-radius: 15px;
    background-clip: padding-box;
  }

  &:after {
    bottom: 4px;
    width: 6px;
    height: 6px;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    border-radius: 50%;
    background-clip: padding-box;
  }
`;
</pre>
<pre class="c--">
const Iphone = Mobile.extend`
  position: relative;
  border: 3px solid #222;
  border-radius: 3px;
  background-clip: padding-box;
  background-color: #fff;
  width: 32px;
  height: 50px;
</pre>
<pre class="c---">
  ${props => props.pressed && css`background-color: red;`};
  `;
</pre>
<pre class="c--">
const Tablet = Mobile.extend`
  position: relative;
  border: 3px solid #222;
  border-radius: 3px;
  background-clip: padding-box;
  background-color: #fff;
  width: 50px;
  height: 60px;
</pre>
<pre class="c---">
  ${props => props.pressed && css`background-color: red;`};
  ${props => props.landscape && css`transform: rotate(90deg);`}
  `;
</pre>
<pre class="c--">
const Desktop = styled.span`
  position: relative;
  border: 3px solid #222;
  border-radius: 3px;
  background-clip: padding-box;
  background-color: #fff;
  width: 120px;
  height: 75px;

  &:before,
  &:after {
    position: absolute;
    content: "";
  }

  &:before {
    top: 4px;
    width: 15px;
    height: 3px;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    border-radius: 15px;
    background-clip: padding-box;
  }

  &:after {
    display: none;
  }
</pre>
  <pre class="c---">
  ${props => props.pressed && css`background-color: red;`};
  `;
</pre>
</code>

<p>You could say to atomize things more and make renderDeviceSelector a component with it's own file but the bigger the project we start to have few problems such as naming files, importing them, switching folders...mental debt for the future self.</p>
<p>What I'm trying to say is find your way and don't settle with your current flow just yet. Try styled-components now.</p>



<p>'The first requirement of The Economist is that it should be readily understandable. Clarity of writing usually follows clarity of thought.' The Economist style Guide rings true to my background as writer, writing is really hard.</p>
<p>At work we code wide/big interfaces so we need a plan/zen on how to approach such a process with fastness and worry-free. We do Javascript and React is our front end framework. Disclaimer: no CS degree, self taught.</p>


<p>Bonus for the mad.</p>

<code>
<pre>
const complexMixin = css`
color: ${props => props.whiteColor ? 'white': 'black'}
`;

const StyledComp = styled.div`
${props => props.complex ? complexMixin : 'color: blue;'}
`;
</pre>

</code>

</body>

</html>